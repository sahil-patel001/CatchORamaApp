import mongoose from "mongoose";

const barcodeSchema = new mongoose.Schema(
  {
    productId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Product",
      required: [true, "Product ID is required"],
      // index: true, // Removed - using specific indexes below
    },
    vendorId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Vendor",
      required: [true, "Vendor ID is required"],
      // index: true, // Removed - using specific indexes below
    },
    barcodeText: {
      type: String,
      required: [true, "Barcode text is required"],
      unique: true,
      trim: true,
      maxlength: [32, "Barcode text must not exceed 32 characters"],
      minlength: [5, "Barcode text must be at least 5 characters"],
      validate: {
        validator: function (value) {
          // Validate barcode format: {VendorPrefix}-{ProductName}-{Price}$
          const barcodeRegex = /^[A-Za-z0-9]+-[A-Za-z0-9]+-\d+\.\d{2}\$$/;
          return barcodeRegex.test(value);
        },
        message:
          "Barcode text must follow format: {VendorPrefix}-{ProductName}-{Price}$",
      },
    },
    vendorPrefix: {
      type: String,
      required: [true, "Vendor prefix is required"],
      trim: true,
      maxlength: [10, "Vendor prefix must not exceed 10 characters"],
      minlength: [1, "Vendor prefix must be at least 1 character"],
      // index: true, // Removed - using specific indexes below
    },
    productName: {
      type: String,
      required: [true, "Product name is required"],
      trim: true,
      maxlength: [200, "Product name must not exceed 200 characters"],
      minlength: [1, "Product name must be at least 1 character"],
    },
    price: {
      type: Number,
      required: [true, "Price is required"],
      min: [0, "Price cannot be negative"],
      max: [999999.99, "Price cannot exceed $999,999.99"],
    },
    formattedPrice: {
      type: String,
      required: [true, "Formatted price is required"],
      match: [/^\d+\.\d{2}\$$/, "Formatted price must follow format: XX.XX$"],
    },
    imageData: {
      dataUrl: {
        type: String,
        required: false, // Optional - images can be generated on-demand
        validate: {
          validator: function (value) {
            if (!value) return true; // Optional field
            return value.startsWith("data:image/");
          },
          message: "Image data must be a valid data URL",
        },
      },
      width: {
        type: Number,
        min: [1, "Image width must be positive"],
        max: [2000, "Image width cannot exceed 2000px"],
      },
      height: {
        type: Number,
        min: [1, "Image height must be positive"],
        max: [2000, "Image height cannot exceed 2000px"],
      },
      format: {
        type: String,
        enum: ["png", "jpeg", "svg"],
        default: "png",
      },
      options: {
        type: Map,
        of: mongoose.Schema.Types.Mixed, // Store barcode generation options
      },
    },
    metadata: {
      generatedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
        required: [true, "Generated by user ID is required"],
      },
      generatedAt: {
        type: Date,
        default: Date.now,
        required: true,
      },
      lastUpdated: {
        type: Date,
        default: Date.now,
      },
      version: {
        type: Number,
        default: 1,
        min: [1, "Version must be at least 1"],
      },
      isActive: {
        type: Boolean,
        default: true,
        // index: true, // Removed - using specific indexes below
      },
    },
    usage: {
      printCount: {
        type: Number,
        default: 0,
        min: [0, "Print count cannot be negative"],
      },
      lastPrinted: {
        type: Date,
      },
      printHistory: [
        {
          printedAt: {
            type: Date,
            default: Date.now,
          },
          printedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: "User",
            required: true,
          },
          quantity: {
            type: Number,
            default: 1,
            min: [1, "Print quantity must be at least 1"],
          },
          method: {
            type: String,
            enum: ["single", "batch", "pdf"],
            default: "single",
          },
        },
      ],
    },
    validation: {
      isValid: {
        type: Boolean,
        default: true,
        // index: true, // Removed - using specific indexes below
      },
      validationErrors: [String],
      lastValidated: {
        type: Date,
        default: Date.now,
      },
    },
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: function (doc, ret) {
        // Don't return large image data by default
        if (
          ret.imageData &&
          ret.imageData.dataUrl &&
          ret.imageData.dataUrl.length > 1000
        ) {
          ret.imageData.hasImage = true;
          ret.imageData.dataUrl = "[IMAGE_DATA]"; // Placeholder
        }
        return ret;
      },
    },
    toObject: { virtuals: true },
  }
);

// Virtual for product information
barcodeSchema.virtual("product", {
  ref: "Product",
  localField: "productId",
  foreignField: "_id",
  justOne: true,
});

// Virtual for vendor information
barcodeSchema.virtual("vendor", {
  ref: "Vendor",
  localField: "vendorId",
  foreignField: "_id",
  justOne: true,
});

// Virtual for generated by user information
barcodeSchema.virtual("generatedByUser", {
  ref: "User",
  localField: "metadata.generatedBy",
  foreignField: "_id",
  justOne: true,
});

// Virtual for total prints
barcodeSchema.virtual("totalPrints").get(function () {
  return this.usage.printHistory.reduce(
    (total, print) => total + print.quantity,
    0
  );
});

// Virtual for barcode components
barcodeSchema.virtual("components").get(function () {
  return {
    vendorPrefix: this.vendorPrefix,
    productName: this.productName,
    price: this.price,
    formattedPrice: this.formattedPrice,
  };
});

// Virtual for display format
barcodeSchema.virtual("displayText").get(function () {
  return this.barcodeText.replace(/-/g, " - ");
});

// Indexes for performance
// barcodeSchema.index({ barcodeText: 1 }, { unique: true }); // Removed - unique constraint in field creates index automatically
barcodeSchema.index({ productId: 1 });
barcodeSchema.index({ vendorId: 1 });
barcodeSchema.index({ vendorPrefix: 1 });
barcodeSchema.index({ "metadata.isActive": 1 });
barcodeSchema.index({ "validation.isValid": 1 });
barcodeSchema.index({ createdAt: -1 });
barcodeSchema.index({ "metadata.generatedAt": -1 });

// Compound indexes
barcodeSchema.index({ productId: 1, "metadata.isActive": 1 });
barcodeSchema.index({ vendorId: 1, "metadata.isActive": 1 });
barcodeSchema.index({ vendorPrefix: 1, "metadata.isActive": 1 });

// Pre-save middleware to validate barcode format and update metadata
barcodeSchema.pre("save", function (next) {
  // Update last updated timestamp
  this.metadata.lastUpdated = new Date();

  // Increment version if barcode text changed
  if (this.isModified("barcodeText") && !this.isNew) {
    this.metadata.version += 1;
  }

  // Validate barcode components match the barcode text
  if (
    this.isModified("barcodeText") ||
    this.isModified("vendorPrefix") ||
    this.isModified("productName") ||
    this.isModified("price")
  ) {
    const expectedBarcode = `${this.vendorPrefix}-${this.productName}-${this.formattedPrice}`;
    if (this.barcodeText !== expectedBarcode) {
      return next(new Error("Barcode text does not match components"));
    }
  }

  // Ensure formatted price matches price
  if (this.isModified("price") || this.isModified("formattedPrice")) {
    const expectedFormattedPrice = `${this.price.toFixed(2)}$`;
    if (this.formattedPrice !== expectedFormattedPrice) {
      this.formattedPrice = expectedFormattedPrice;
    }
  }

  next();
});

// Pre-save middleware to validate barcode length
barcodeSchema.pre("save", function (next) {
  if (this.barcodeText && this.barcodeText.length > 32) {
    return next(
      new Error("Barcode text exceeds maximum length of 32 characters")
    );
  }
  next();
});

// Instance method to add print record
barcodeSchema.methods.addPrintRecord = function (
  printedBy,
  quantity = 1,
  method = "single"
) {
  this.usage.printHistory.push({
    printedAt: new Date(),
    printedBy,
    quantity,
    method,
  });
  this.usage.printCount += quantity;
  this.usage.lastPrinted = new Date();
  return this.save();
};

// Instance method to validate barcode
barcodeSchema.methods.validateBarcode = function () {
  const errors = [];

  // Basic format validation
  const barcodeRegex = /^[A-Za-z0-9]+-[A-Za-z0-9]+-\d+\.\d{2}\$$/;
  if (!barcodeRegex.test(this.barcodeText)) {
    errors.push("Invalid barcode format");
  }

  // Length validation
  if (this.barcodeText.length > 32) {
    errors.push("Barcode text exceeds 32 characters");
  }

  // Component validation
  const expectedBarcode = `${this.vendorPrefix}-${this.productName}-${this.formattedPrice}`;
  if (this.barcodeText !== expectedBarcode) {
    errors.push("Barcode text does not match components");
  }

  // Price validation
  const expectedFormattedPrice = `${this.price.toFixed(2)}$`;
  if (this.formattedPrice !== expectedFormattedPrice) {
    errors.push("Formatted price does not match price value");
  }

  // Update validation status
  this.validation.isValid = errors.length === 0;
  this.validation.validationErrors = errors;
  this.validation.lastValidated = new Date();

  return {
    isValid: this.validation.isValid,
    errors: this.validation.validationErrors,
  };
};

// Instance method to deactivate barcode
barcodeSchema.methods.deactivate = function () {
  this.metadata.isActive = false;
  this.metadata.lastUpdated = new Date();
  return this.save();
};

// Instance method to activate barcode
barcodeSchema.methods.activate = function () {
  this.metadata.isActive = true;
  this.metadata.lastUpdated = new Date();
  return this.save();
};

// Instance method to update image data
barcodeSchema.methods.updateImageData = function (imageData) {
  this.imageData = {
    ...this.imageData,
    ...imageData,
  };
  this.metadata.lastUpdated = new Date();
  return this.save();
};

// Static method to find by product
barcodeSchema.statics.findByProduct = function (productId, options = {}) {
  const query = { productId };
  if (options.activeOnly !== false) {
    query["metadata.isActive"] = true;
  }
  if (options.validOnly !== false) {
    query["validation.isValid"] = true;
  }
  return this.find(query).populate("product vendor");
};

// Static method to find by vendor
barcodeSchema.statics.findByVendor = function (vendorId, options = {}) {
  const query = { vendorId };
  if (options.activeOnly !== false) {
    query["metadata.isActive"] = true;
  }
  if (options.validOnly !== false) {
    query["validation.isValid"] = true;
  }
  return this.find(query).populate("product vendor");
};

// Static method to find by barcode text
barcodeSchema.statics.findByBarcodeText = function (barcodeText) {
  return this.findOne({ barcodeText }).populate("product vendor");
};

// Static method to check uniqueness
barcodeSchema.statics.isUnique = async function (
  barcodeText,
  excludeId = null
) {
  const query = { barcodeText };
  if (excludeId) {
    query._id = { $ne: excludeId };
  }
  const existing = await this.findOne(query);
  return !existing;
};

// Static method to get barcode statistics
barcodeSchema.statics.getStats = async function (filter = {}) {
  const pipeline = [
    { $match: filter },
    {
      $group: {
        _id: null,
        totalBarcodes: { $sum: 1 },
        activeBarcodes: {
          $sum: { $cond: ["$metadata.isActive", 1, 0] },
        },
        validBarcodes: {
          $sum: { $cond: ["$validation.isValid", 1, 0] },
        },
        totalPrints: { $sum: "$usage.printCount" },
        avgPrintsPerBarcode: { $avg: "$usage.printCount" },
      },
    },
  ];

  const stats = await this.aggregate(pipeline);
  return (
    stats[0] || {
      totalBarcodes: 0,
      activeBarcodes: 0,
      validBarcodes: 0,
      totalPrints: 0,
      avgPrintsPerBarcode: 0,
    }
  );
};

// Static method to clean up inactive barcodes
barcodeSchema.statics.cleanupInactive = function (olderThanDays = 90) {
  const cutoffDate = new Date(Date.now() - olderThanDays * 24 * 60 * 60 * 1000);
  return this.deleteMany({
    "metadata.isActive": false,
    "metadata.lastUpdated": { $lt: cutoffDate },
  });
};

const Barcode = mongoose.model("Barcode", barcodeSchema);

export default Barcode;
